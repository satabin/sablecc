$comment$
This file is part of SableCC ( http://sablecc.org ).

See the NOTICE file distributed with this work for copyright information.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
$end$

$comment: ========== header ========== $

$text: header $
/* This file was generated by SableCC ( http://sablecc.org ). */
$end: header $

$comment: ========== default_package ========== $

$macro: default_package(language_name) $
package $language_name;
$end: default_package $

$comment: ========== specified_package ========== $

$macro: specified_package(language_name, package) $
package $package.$language_name;
$end: specified_package $

$comment: ========== node ========== $

$macro: node $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class Node {

  public abstract Type getType();

  public static enum Type {
$macro: node_type_enum_entry(name) $
    T_$name,
$end: node_type_enum_entry $
    TEnd,
    TAnonymous;
  }

  public static enum ProductionType {
$macro: node_production_type_enum_entry(name) $
    T_$name,
$end: node_production_type_enum_entry $
    TNotAProduction;
  }

  public abstract String getText();
  public abstract int getLine();
  public abstract int getPos();
  public abstract void apply(Walker walker);
  public abstract void applyOnChildren(Walker walker);

  private Node parent;

  public Node getParent() {
    return this.parent;
  }

  void setParent(Node parent) {
    this.parent = parent;
  }

  @Override
  public String toString() {
    return "\\"" + getText() + "\\"@(" + getLine() + "," + getPos() + ")";
  }

}
$end: node $

$comment: ========== entry ========== $

$macro: entry $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class Entry<E> {

    E element;

    Entry<E> next;

    Entry<E> previous;

    Entry(
            E element,
            Entry<E> next,
            Entry<E> previous) {

        this.element = element;
        this.next = next;
        this.previous = previous;

    }
}

$end: entry$

$comment: ========== node_list ========== $

$macro: node_list $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.util.*;

public class NodeList<TNode extends Node>extends Node
        implements Iterable<TNode> {

        int lowerBound;
        int upperBound;

        int size = 0;

        private final int INF = -1;

        Entry<TNode> header = new Entry<TNode>(null,null,null);

        NodeList(){
                this.header.next = this.header.previous = this.header;
        }

        NodeList(int lowerBound){
            this.header.next = this.header.previous = this.header;
                this.lowerBound = lowerBound;
                this.upperBound = INF;
        }

        NodeList(int lowerBound,int upperBound){
            this.header.next = this.header.previous = this.header;
            this.lowerBound = lowerBound;
                this.upperBound = upperBound;
        }

        void add(TNode element){
                 Entry<TNode> newEntry = new Entry<TNode>(element, this.header, this.header.previous);
                 newEntry.previous.next = newEntry;
                 newEntry.next.previous = newEntry;
                 size++;

                 //TODO Control list bounds
        }

        void addAll(NodeList<TNode> elements){
                this.header.previous.next = elements.header.next;
                elements.header.next.previous = this.header.previous;
                this.header.previous = elements.header.previous;
                elements.header.previous.next = this.header;
                this.size += elements.size;

                //TODO Control list bounds
        }

        public int size(){

                return size;
        }

 @Override
  public String getText() {
          return "";
  }

  @Override
  public int getLine() {
    return 0;
  }

  @Override
  public int getPos() {
    return 0;
  }

  @Override
  public Type getType() {
    return Type.TAnonymous;
  }

  @Override
  public void applyOnChildren(Walker walker) {
        for (TNode node : this) {
            node.apply(walker);
        }
  }

  @Override
  public void apply(Walker walker){
    this.applyOnChildren(walker);
  }

  @Override
  public Iterator<TNode> iterator(){
          return new NodeListItr();
  }

  private class NodeListItr
            implements Iterator<TNode> {

    private int cursor = 0;

    private Entry<TNode> current;

    NodeListItr() {

         this.current = NodeList.this.header;
    }

    @Override
    public boolean hasNext() {

        return this.cursor != size();
    }

    @Override
    public TNode next() {

        this.cursor++;
        current = this.current.next;
        return this.current.element;
    }

    @Override
    public void remove() {

    }
  }

}

$end: node_list$

$comment: ========== pair_node_list ========== $

$macro: pair_node_list $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.util.*;

public class PairNodeList<TNodeLeft extends Node, TNodeRight extends Node>
        extends Node {

    int lowerBound;

    int upperBound;

    int size = 0;

    private final int INF = -1;

    Entry<TNodeLeft> leftHeader = new Entry<TNodeLeft>(null, null, null);

    Entry<TNodeRight> rightHeader = new Entry<TNodeRight>(null, null, null);

    PairNodeList(){
        this.leftHeader.next = this.leftHeader.previous = this.leftHeader;
        this.rightHeader.next = this.rightHeader.previous = this.rightHeader;
    }

    PairNodeList(int lowerBound){
        this.leftHeader.next = this.leftHeader.previous = this.leftHeader;
        this.rightHeader.next = this.rightHeader.previous = this.rightHeader;
        this.lowerBound = lowerBound;
        this.upperBound = INF;
    }

    PairNodeList(int lowerBound,int upperBound){
        this.leftHeader.next = this.leftHeader.previous = this.leftHeader;
        this.rightHeader.next = this.rightHeader.previous = this.rightHeader;
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }

    void addLeft(
            TNodeLeft element) {

        Entry<TNodeLeft> newEntry = new Entry<TNodeLeft>(element,
                this.leftHeader, this.leftHeader.previous);
        newEntry.previous.next = newEntry;
        newEntry.next.previous = newEntry;
        this.size++;

        // TODO Control list bounds
    }

    void addRight(
            TNodeRight element) {

        Entry<TNodeRight> newEntry = new Entry<TNodeRight>(element,
                this.rightHeader, this.rightHeader.previous);
        newEntry.previous.next = newEntry;
        newEntry.next.previous = newEntry;
        this.size++;

        // TODO Control list bounds
    }

    void addAll(
            PairNodeList<TNodeLeft, TNodeRight> elements) {

        this.leftHeader.previous.next = elements.leftHeader.next;
        elements.leftHeader.next.previous = this.leftHeader.previous;
        this.leftHeader.previous = elements.leftHeader.previous;
        elements.leftHeader.previous.next = this.leftHeader;

        this.rightHeader.previous.next = elements.rightHeader.next;
        elements.rightHeader.next.previous = this.rightHeader.previous;
        this.rightHeader.previous = elements.rightHeader.previous;
        elements.rightHeader.previous.next = this.rightHeader;

        this.size += elements.size;

        // TODO Control list bounds
    }

     void addAll(
            SeparatedNodeList<TNodeLeft, TNodeRight> elements) {

        this.leftHeader.previous.next = elements.leftHeader.next;
        elements.leftHeader.next.previous = this.leftHeader.previous;
        this.leftHeader.previous = elements.leftHeader.previous;
        elements.leftHeader.previous.next = this.leftHeader;

        this.rightHeader.previous.next = elements.rightHeader.next;
        elements.rightHeader.next.previous = this.rightHeader.previous;
        this.rightHeader.previous = elements.rightHeader.previous;
        elements.rightHeader.previous.next = this.rightHeader;

        this.size += elements.size;
        // TODO Control list bounds
    }

     void addAllReverse(
            SeparatedNodeList<TNodeRight, TNodeLeft> elements) {

            this.leftHeader.previous.next = elements.rightHeader.next;
            elements.leftHeader.next.previous = this.rightHeader.previous;
            this.leftHeader.previous = elements.rightHeader.previous;
            elements.leftHeader.previous.next = this.rightHeader;

            this.rightHeader.previous.next = elements.leftHeader.next;
            elements.rightHeader.next.previous = this.leftHeader.previous;
            this.rightHeader.previous = elements.leftHeader.previous;
            elements.rightHeader.previous.next = this.leftHeader;

        this.size += elements.size;
        // TODO Control list bounds
    }

    NodeList<TNodeLeft> getLeft(){
        NodeList<TNodeLeft> list = new NodeList<TNodeLeft>();
        Iterator<TNodeLeft> leftIterator = this.leftIterator();

        while(leftIterator.hasNext()){
            list.add(leftIterator.next());
        }

        return list;
    }

    NodeList<TNodeRight> getRight(){
        NodeList<TNodeRight> list = new NodeList<TNodeRight>();
        Iterator<TNodeRight> rightIterator = this.rightIterator();

        while(rightIterator.hasNext()){
            list.add(rightIterator.next());
        }

        return list;
    }

    public Iterator<TNodeLeft> leftIterator() {

        return new LeftNodeListItr();
    }

    public Iterator<TNodeRight> rightIterator() {

        return new RightNodeListItr();
    }

    public int size() {

        return this.size;
    }

    @Override
    public Type getType() {

        return Type.TAnonymous;
    }

    @Override
    public String getText() {

        return "";
    }

    @Override
    public int getLine() {

        return 0;
    }

    @Override
    public int getPos() {

        return 0;
    }

    @Override
    public void apply(
            Walker walker) {

        this.applyOnChildren(walker);

    }

    @Override
    public void applyOnChildren(
            Walker walker) {

        Iterator<TNodeLeft> leftIterator = leftIterator();
        Iterator<TNodeRight> rightIterator = rightIterator();

        while(leftIterator.hasNext()){
            leftIterator.next().apply(walker);
            rightIterator.next().apply(walker);
        }

    }

    private class LeftNodeListItr
            implements Iterator<TNodeLeft> {

        private int cursor = 0;

        private int size;

        private Entry<TNodeLeft> current;

        LeftNodeListItr() {

            this.current = PairNodeList.this.leftHeader;
            this.size = size() /2;
        }

        @Override
        public boolean hasNext() {

            return this.cursor != size;
        }

        @Override
        public TNodeLeft next() {

            this.cursor++;
            this.current = this.current.next;
            return this.current.element;
        }

        @Override
        public void remove() {

        }
    }

    private class RightNodeListItr
            implements Iterator<TNodeRight> {

        private int cursor = 0;

        private int size;

        private Entry<TNodeRight> current;

        RightNodeListItr() {

            this.current = PairNodeList.this.rightHeader;
            this.size = size() /2;
        }

        @Override
        public boolean hasNext() {

            return this.cursor != size;
        }

        @Override
        public TNodeRight next() {

            this.cursor++;
            this.current = this.current.next;
            return this.current.element;
        }

        @Override
        public void remove() {

        }
    }

}
$end: pair_node_list$

$comment: ========== separated_node_list ========== $

$macro: separated_node_list $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.util.*;

public class SeparatedNodeList<TNodeLeft extends Node, TNodeRight extends Node>
        extends Node
        implements Iterable<TNodeLeft> {

    int lowerBound;

    int upperBound;

    int size = 0;

    private final int INF = -1;

    Entry<TNodeLeft> leftHeader = new Entry<TNodeLeft>(null, null, null);

    Entry<TNodeRight> rightHeader = new Entry<TNodeRight>(null, null, null);

    SeparatedNodeList(){
        this.leftHeader.next = this.leftHeader.previous = this.leftHeader;
        this.rightHeader.next = this.rightHeader.previous = this.rightHeader;
    }

    SeparatedNodeList(int lowerBound){
        this.leftHeader.next = this.leftHeader.previous = this.leftHeader;
        this.rightHeader.next = this.rightHeader.previous = this.rightHeader;
        this.lowerBound = lowerBound;
        this.upperBound = INF;
    }

    SeparatedNodeList(int lowerBound,int upperBound){
        this.leftHeader.next = this.leftHeader.previous = this.leftHeader;
        this.rightHeader.next = this.rightHeader.previous = this.rightHeader;
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }

    void addLeft(
            TNodeLeft element) {

        Entry<TNodeLeft> newEntry = new Entry<TNodeLeft>(element,
                this.leftHeader, this.leftHeader.previous);
        newEntry.previous.next = newEntry;
        newEntry.next.previous = newEntry;
        this.size++;

        // TODO Control list bounds
    }

    void addRight(
            TNodeRight element) {

        Entry<TNodeRight> newEntry = new Entry<TNodeRight>(element,
                this.rightHeader, this.rightHeader.previous);
        newEntry.previous.next = newEntry;
        newEntry.next.previous = newEntry;
        this.size++;

        // TODO Control list bounds
    }

     void addAll(
            PairNodeList<TNodeLeft, TNodeRight> elements) {

        this.leftHeader.previous.next = elements.leftHeader.next;
        elements.leftHeader.next.previous = this.leftHeader.previous;
        this.leftHeader.previous = elements.leftHeader.previous;
        elements.leftHeader.previous.next = this.leftHeader;

        this.rightHeader.previous.next = elements.rightHeader.next;
        elements.rightHeader.next.previous = this.rightHeader.previous;
        this.rightHeader.previous = elements.rightHeader.previous;
        elements.rightHeader.previous.next = this.rightHeader;

        this.size += elements.size;

        // TODO Control list bounds
    }

     void addAll(
            SeparatedNodeList<TNodeLeft, TNodeRight> elements) {

        this.leftHeader.previous.next = elements.leftHeader.next;
        elements.leftHeader.next.previous = this.leftHeader.previous;
        this.leftHeader.previous = elements.leftHeader.previous;
        elements.leftHeader.previous.next = this.leftHeader;

        this.rightHeader.previous.next = elements.rightHeader.next;
        elements.rightHeader.next.previous = this.rightHeader.previous;
        this.rightHeader.previous = elements.rightHeader.previous;
        elements.rightHeader.previous.next = this.rightHeader;

        this.size += elements.size;
        // TODO Control list bounds
    }

    void addAllReverse(
            PairNodeList<TNodeRight, TNodeLeft> elements) {

            this.leftHeader.previous.next = elements.rightHeader.next;
            elements.leftHeader.next.previous = this.rightHeader.previous;
            this.leftHeader.previous = elements.rightHeader.previous;
            elements.leftHeader.previous.next = this.rightHeader;

            this.rightHeader.previous.next = elements.leftHeader.next;
            elements.rightHeader.next.previous = this.leftHeader.previous;
            this.rightHeader.previous = elements.leftHeader.previous;
            elements.rightHeader.previous.next = this.leftHeader;

        this.size += elements.size;

        // TODO Control list bounds
    }

     void addAllReverse(
            SeparatedNodeList<TNodeRight, TNodeLeft> elements) {

            this.leftHeader.previous.next = elements.rightHeader.next;
            elements.leftHeader.next.previous = this.rightHeader.previous;
            this.leftHeader.previous = elements.rightHeader.previous;
            elements.leftHeader.previous.next = this.rightHeader;

            this.rightHeader.previous.next = elements.leftHeader.next;
            elements.rightHeader.next.previous = this.leftHeader.previous;
            this.rightHeader.previous = elements.leftHeader.previous;
            elements.rightHeader.previous.next = this.leftHeader;

        this.size += elements.size;
        // TODO Control list bounds
    }

    NodeList<TNodeLeft> getLeft(){
        NodeList<TNodeLeft> list = new NodeList<TNodeLeft>();
        Iterator<TNodeLeft> leftIterator = this.iterator();

        while(leftIterator.hasNext()){
            list.add(leftIterator.next());
        }

        return list;
    }

    NodeList<TNodeRight> getRight(){
        NodeList<TNodeRight> list = new NodeList<TNodeRight>();
        Iterator<TNodeRight> rightIterator = this.separatorIterator();

        while(rightIterator.hasNext()){
            list.add(rightIterator.next());
        }

        return list;
    }

    @Override
    public Iterator<TNodeLeft> iterator() {

        return new LeftNodeListItr();
    }

    public Iterator<TNodeRight> separatorIterator() {

        return new RightNodeListItr();
    }

    public int size() {

        return this.size;
    }

    @Override
    public Type getType() {

        return Type.TAnonymous;
    }

    @Override
    public String getText() {

        return "";
    }

    @Override
    public int getLine() {

        return 0;
    }

    @Override
    public int getPos() {

        return 0;
    }

    @Override
    public void apply(
            Walker walker) {

        this.applyOnChildren(walker);

    }

    @Override
    public void applyOnChildren(
            Walker walker) {

        Iterator<TNodeLeft> leftIterator = iterator();
        Iterator<TNodeRight> rightIterator = separatorIterator();

        leftIterator.next().apply(walker);

        while(leftIterator.hasNext()){
            rightIterator.next().apply(walker);
            leftIterator.next().apply(walker);

        }

    }

    private class LeftNodeListItr
            implements Iterator<TNodeLeft> {

        private int cursor = 0;

        private int size;

        private Entry<TNodeLeft> current;

        LeftNodeListItr() {

            this.current = SeparatedNodeList.this.leftHeader;
            this.size = size() / 2 + 1;
        }

        @Override
        public boolean hasNext() {

            return this.cursor != this.size;
        }

        @Override
        public TNodeLeft next() {

            this.cursor++;
            this.current = this.current.next;
            return this.current.element;
        }

        @Override
        public void remove() {

        }
    }

    private class RightNodeListItr
            implements Iterator<TNodeRight> {

        private int cursor = 0;

        private int size;

        private Entry<TNodeRight> current;

        RightNodeListItr() {

            this.current = SeparatedNodeList.this.rightHeader;
            this.size = size() / 2;
        }

        @Override
        public boolean hasNext() {

            return this.cursor != size;
        }

        @Override
        public TNodeRight next() {

            this.cursor++;
            this.current = this.current.next;
            return this.current.element;
        }

        @Override
        public void remove() {

        }
    }

}

$end: separated_node_list$

$comment: ========== token ========== $

$macro: token $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class Token
    extends Node {

  private final String text;
  private final int line;
  private final int pos;

  Token(String text, int line, int pos) {
    this.text = text;
    this.line = line;
    this.pos = pos;
  }

  @Override
  public String getText() {
    return this.text;
  }

  @Override
  public int getLine() {
    return this.line;
  }

  @Override
  public int getPos() {
    return this.pos;
  }

    static enum InternalType {
$macro: node_internal_type_enum_entry(name) $
    T_$name,
$end: node_internal_type_enum_entry $
    TEnd;
  }

  abstract InternalType getInternalType();

  @Override
  public void applyOnChildren(Walker walker) {
  }

   @Override
  public void apply(Walker walker) {

  }
}
$end: token $

$comment: ========== custom_token ========== $

$macro: custom_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class N$name
    extends Token {

  N$name(String text, int line, int pos) {
    super(text, line, pos);
  }

  @Override
  public Type getType() {
    return Type.T_$name;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.T_$name;
  }

  @Override
  public void apply(Walker walker) {
    walker.in$name(this);
    walker.case$name(this);
    walker.out$name(this);
  }
}
$end: custom_token $

$comment: ========== anonymous_token ========== $

$macro: anonymous_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class N$name
    extends Token {

  N$name(String text, int line, int pos) {
    super(text, line, pos);
  }

  @Override
  public Type getType() {
    return Type.TAnonymous;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.T_$name;
  }

  @Override
  public void apply(Walker walker) {
    walker.defaultIn(this);
    walker.defaultCase(this);
    walker.defaultOut(this);
  }
}
$end: anonymous_token $

$comment: ========== lexer ========== $

$macro: lexer $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;

public class Lexer {

  private final BufferedReader br;
  private final StringBuilder buffer = new StringBuilder();
  private boolean eof;
  private int line = 1;
  private int pos = 1;
  private boolean last_is_cr;
  private StringBuilder sb;
  private int acceptLine;
  private int acceptPos;
  private int current_sb_length;
  private boolean sb_contains_eof;
$macro: marker_declaration(name) $
  private int marker$name;
$end: marker_declaration $

$macro: set_marker_declaration(name) $
  void setMarker$name() {
    this.marker$name = this.current_sb_length;
  }
$end: set_marker_declaration $

  public Lexer(Reader reader) {

    this.br = new BufferedReader(reader);
  }

  public Token next()
      throws LexerException, IOException {
    Token token;
    do {
      token = internalNext();
    } while (token == null);
    return token;
  }

  Token internalNext()
      throws LexerException, IOException {

    boolean first = true;

    StringBuilder sb = new StringBuilder();
    State state = S_0.instance;

    while(state.getStateType() == State.StateType.TRANSITION) {
      TransitionState transitionState = (TransitionState) state;

      this.current_sb_length = sb.length();
      transitionState.setMarker(this);

      Symbol symbol;
      if(buffer.length() > 0) {
        char c = buffer.charAt(0);
        buffer.deleteCharAt(0);

        sb.append(c);
        symbol = Symbol.getSymbol(c);
      }
      else if(this.eof) {
        if(sb.length() == 0) {
          return new End(this.line, this.pos);
        }
        this.sb_contains_eof = true;
        symbol = Symbol.Symbol_end;
      }
      else {
        int i = br.read();
        if(i == -1) {
          this.eof = true;
          br.close();

          if(sb.length() == 0) {
            return new End(this.line, this.pos);
          }
          this.sb_contains_eof = true;
          symbol = Symbol.Symbol_end;
        }
        else {
          char c = (char) i;

          sb.append(c);
          symbol = Symbol.getSymbol(c);
        }
      }

      if(symbol == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }

      state = transitionState.getTarget(symbol);

      if(state == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos);
      }
    }

    FinalState finalState = (FinalState) state;

    this.sb = sb;

    return finalState.getToken(this);
  }

  int getAcceptLine() {
    return this.acceptLine;
  }

  int getAcceptPos() {
    return this.acceptPos;
  }

  private void updateLinePos(String text) {
    if(this.last_is_cr) {
      if(text.length() > 0) {
        if(text.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
      else if(this.buffer.length() > 0) {
        if(this.buffer.charAt(0) != 10) {
          this.last_is_cr = false;
          this.line++;
          this.pos = 1;
        }
      }
    }

    this.acceptLine = line;
    this.acceptPos = pos;

    for(int i = 0; i < text.length(); i++) {
      char c = text.charAt(i);

      if(c == 10) {
        this.line++;
        this.pos = 1;
      }
      else {
        if(last_is_cr) {
          this.line++;
          this.pos = 2;
        }
        else {
          this.pos++;
        }
      }

      this.last_is_cr = c == 13;
    }
  }

  String accept(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
      backCount--;
    }
    String text = this.sb.toString().substring(0, this.sb.length() - backCount);
    String leftover = this.sb.toString().substring(this.sb.length() - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }

$macro: accept_marker_declaration(name) $
  String acceptWithMarker$name(int backCount) {
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false;
    }
    String text = this.sb.toString().substring(0, this.marker$name - backCount);
    String leftover = this.sb.toString().substring(this.marker$name - backCount, this.sb.length());
    this.buffer.insert(0, leftover);
    updateLinePos(text);
    return text;
  }
$end: accept_marker_declaration $

}
$end: lexer $

$comment: ========== state ========== $

$macro: state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class State {

  enum StateType {
    TRANSITION,
    FINAL;
  }

  abstract StateType getStateType();
}
$end: state $

$comment: ========== transition_state ========== $

$macro: transition_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class TransitionState
    extends State {

  abstract void setMarker(Lexer lexer);
  abstract State getTarget(Symbol symbol);

  StateType getStateType() {
    return State.StateType.TRANSITION;
  }
}
$end: transition_state $

$comment: ========== final_state ========== $

$macro: final_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class FinalState
    extends State {

  abstract Token getToken(Lexer lexer);

  StateType getStateType() {
    return State.StateType.FINAL;
  }
}
$end: final_state $

$comment: ========== transition_state_singleton ========== $

$macro: transition_state_singleton(number) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class S_$number
    extends TransitionState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

$macro: set_marker(name) $
  void setMarker(Lexer lexer) {
    lexer.setMarker$name();
  }
$end: set_marker $
$macro: no_marker $
  void setMarker(Lexer lexer) {
  }
$end: no_marker $

  State getTarget(Symbol symbol) {
    switch(symbol) {
$macro: transition_target(symbol, target) $
    case Symbol_$(symbol):
      return S_$target.instance;
$end: transition_target $
    default:
      return null;
    }
  }

}
$end: transition_state_singleton $

$comment: ========== final_state_singleton ========== $

$macro: final_state_singleton(number,back_count) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class S_$number
    extends FinalState {

  static final S_$number instance = new S_$number();

  private S_$number() {
  }

  Token getToken(Lexer lexer) {
$macro: accept_token_no_marker $
    String text = lexer.accept($back_count);
$end: accept_token_no_marker $
$macro: accept_token_with_marker(marker_name) $
    String text = lexer.acceptWithMarker$marker_name($back_count);
$end: accept_token_with_marker $
    int line = lexer.getAcceptLine();
    int pos = lexer.getAcceptPos();

$macro: accept_normal_token(token_name) $
    return new N$token_name(text, line, pos);
$end: accept_normal_token $
$macro: accept_ignored_token $
    return null;
$end: accept_ignored_token $
  }
}
$end: final_state_singleton $

$comment: ========== symbol ========== $

$macro: symbol $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

enum Symbol {
$macro: symbol_declaration(name) $
  Symbol_$name,
$end: symbol_declaration $
  Symbol_end;

  static Symbol getSymbol(char c) {
    switch(c) {
$macro: single_char(bound, name) $
    case $(bound): return Symbol_$name;
$end: single_char $
    default:
$macro: open_interval(name) $
      return Symbol_$name;
$end: open_interval $
$macro: open_left_interval(upper_bound, name) $
      if(c <= $upper_bound) {
        return Symbol_$name;
      }
$end: open_left_interval $
$macro: open_right_interval(lower_bound, name) $
      if(c >= $lower_bound) {
        return Symbol_$name;
      }
$end: open_right_interval $
$macro: interval(lower_bound, upper_bound, name) $
      if(c >= $lower_bound && c <= $upper_bound) {
        return Symbol_$name;
      }
$end: interval $
    }

    return null;
  }
}
$end: symbol $

$comment: ========== lexer_exception ========== $

$macro: lexer_exception $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class LexerException
    extends Exception {

  private char c;
  private int line;
  private int pos;

  public LexerException(char c, int line, int pos) {
    this.c = c;
    this.line = line;
    this.pos = pos;
  }

  public char getChar() {
    return this.c;
  }

  public int getLine() {
    return this.line;
  }

  public int getPos() {
    return this.pos;
  }

  public String getMessage() {
    return "unrecognized char '" + getChar() + "' on line " + getLine() + ", pos " + getPos();
  }
}
$end: lexer_exception $

$comment: ========== parser_exception ========== $

$macro: parser_exception $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class ParserException
    extends Exception {

  private Token token;

  public ParserException(Token token) {
    this.token = token;
  }

  public Token getToken() {
    return this.token;
  }

  public String getMessage() {
    return "unexpected token '" + this.token.getText() + "' on line " + this.token.getLine() + ", pos " + this.token.getPos();
  }
}
$end: parser_exception $

$comment: ========== end ========== $

$macro: end $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class End
    extends Token {

  public End(int line, int pos) {
    super("", line, pos);
  }

  @Override
  public Type getType() {
    return Type.TEnd;
  }

  @Override
  InternalType getInternalType() {
    return InternalType.TEnd;
  }

  @Override
  public void apply(Walker walker) {
    walker.defaultIn(this);
    walker.defaultCase(this);
    walker.defaultOut(this);
  }
}
$end: end $

$comment: ========== tester ========== $

$macro: tester $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;

public class Tester {

    static public void main(
            String[] args) {

        try {
            Reader reader = new FileReader(args[0]);
            Parser parser = new Parser(reader);
            Node tree = parser.parse();

            tree.apply(new Walker() {

                @Override
                public void defaultCase(
                        Node node) {

                    if (node instanceof Token) {
                        Token token = (Token) node;
                        System.out.println(token.getText());
                    }
                    else {
                        super.defaultCase(node);
                    }

                }
            });

        }
        catch (LexerException e) {
            System.out.println(e.getMessage() + "," + e.getPos()
                    + ". Syntax error: Unexpected character '" + e.getChar()
                    + "'.");
        }
        catch (ParserException e) {
            System.out.println(e.getMessage());
        }

        catch (IOException e) {
            System.out.println(e.getMessage());
        }
    }
}
$end: tester $

$comment: ========== production ========== $

$macro: production(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public abstract class N$name
    extends Node {

}
$end: production $

$comment: ========== public ========== $

$macro: public $
public $no_eol$
$end: public $

$comment: ========== alternative ========== $

$macro: alternative(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

$expand: public $
class N$name
    extends $expand: alternative_named_parent, alternative_node_parent $ {
$macro: alternative_named_parent(parent) $
N$(parent)$no_eol$
$end: alternative_named_parent $
$macro: alternative_node_parent $
Node$no_eol$
$end: alternative_node_parent $

  private final int line;
  private final int pos;
$expand: normal_element_declaration,list_element_declaration,alternated_list_element_declaration,separated_list_element_declaration, end_element_declaration $

  @Override
  public int getLine() {
    return this.line;
  }

  @Override
  public int getPos() {
    return this.pos;
  }

  @Override
  public String getText() {
    return null;
  }

  @Override
  public void apply(Walker walker) {
$macro: alt_normal_apply $
    walker.in$name(this);
    walker.case$name(this);
    walker.out$name(this);
$end: alt_normal_apply $
$macro: alt_anonymous_apply $
    walker.defaultIn(this);
    walker.defaultCase(this);
    walker.defaultOut(this);
$end: alt_anonymous_apply $
  }

  @Override
  public void applyOnChildren(Walker walker) {
$expand: normal_child_apply, end_child_apply $
$macro: normal_child_apply(element_name) $
    this.e$element_name.apply(walker);
$end: normal_child_apply $
$macro: end_child_apply $
    this.e\$end.apply(walker);
$end: end_child_apply $
  }

  N$name(int line, int pos$expand: normal_constructor_parameter,list_constructor_parameter,alternated_list_constructor_parameter,separated_list_constructor_parameter, end_constructor_parameter, before_first=", ", separator=", " $) {
$macro: normal_constructor_parameter(element_type, element_name) $
N$element_type p$(element_name)$no_eol$
$end: normal_constructor_parameter $
$macro: list_constructor_parameter(list_type, element_name) $
NodeList<N$list_type> p$(element_name)$no_eol$
$end: list_constructor_parameter $
$macro: separated_list_constructor_parameter(left_list_type,right_list_type, element_name) $
SeparatedNodeList<N$(left_list_type),N$(right_list_type)> p$(element_name)$no_eol$
$end: separated_list_constructor_parameter $
$macro: alternated_list_constructor_parameter(left_list_type,right_list_type, element_name) $
PairNodeList<N$(left_list_type),N$(right_list_type)> p$(element_name)$no_eol$
$end: alternated_list_constructor_parameter $
$macro: end_constructor_parameter $
End p\$end$no_eol$
$end: end_constructor_parameter $
    this.line = line;
    this.pos = pos;
$macro: normal_contructor_initialization(element_name) $
    this.e$element_name = p$element_name;
$end: normal_contructor_initialization $
$macro: end_contructor_initialization $
    this.e\$end = p\$end;
$end: end_contructor_initialization $
  }

  @Override
  public Type getType() {
$macro: named_alt_type $
    return Type.T_$name;
$end: named_alt_type $
$macro: anonymous_alt_type $
    return Type.TAnonymous;
$end: anonymous_alt_type $
  }

$expand: public_element_accessor, before_first="\n", separator="\n" $
$expand: normal_element_accessor, end_element_accessor, before_first="\n", separator="\n" $
$macro: normal_element_declaration(element_type, element_name) $
  private final N$element_type e$element_name;
$end: normal_element_declaration $
$macro: list_element_declaration(list_type, element_name) $
  private final NodeList<N$list_type> e$element_name;
$end: list_element_declaration $
$macro: separated_list_element_declaration(left_list_type,right_list_type, element_name) $
  private final SeparatedNodeList<N$left_list_type,N$right_list_type> e$element_name;
$end: separated_list_element_declaration $
$macro: alternated_list_element_declaration(left_list_type,right_list_type, element_name) $
  private final PairNodeList<N$left_list_type,N$right_list_type> e$element_name;
$end: alternated_list_element_declaration $
$macro: public_element_accessor(element_name) $
  public $expand: public_element_type,public_list_element_type,public_alternated_list_element_type,public_separated_list_element_type, token_element_type $ get_$element_name() {
$macro: public_element_type(element_type) $
N$(element_type)$no_eol$
$end: public_element_type $
$macro: public_list_element_type(element_type) $
NodeList<N$(element_type)>$no_eol$
$end: public_list_element_type $
$macro: public_separated_list_element_type(left_element_type,right_element_type) $
SeparatedNodeList<N$(left_element_type),N$(right_element_type)>$no_eol$
$end: public_separated_list_element_type $
$macro: public_alternated_list_element_type(left_element_type,right_element_type) $
PairNodeList<N$(left_element_type),N$(right_element_type)>$no_eol$
$end: public_alternated_list_element_type $


$macro: token_element_type $
Token$no_eol$
$end: token_element_type $
    return this.e$element_name;
  }
$end: public_element_accessor$
$macro: normal_element_accessor(element_type, element_name) $
  N$element_type internalGet$element_name() {
    return this.e$element_name;
  }
$end: normal_element_accessor$
$macro: list_element_accessor(list_type, element_name) $
  NodeList<N$list_type> internalGet$element_name() {
    return this.e$element_name;
  }
$end: list_element_accessor$
$macro: separated_list_element_accessor(left_list_type,right_list_type, element_name) $
  SeparatedNodeList<N$left_list_type,N$right_list_type> internalGet$element_name() {
    return this.e$element_name;
  }
$end: separated_list_element_accessor$
$macro: alternated_list_element_accessor(left_list_type,right_list_type, element_name) $
  PairNodeList<N$left_list_type,N$right_list_type> internalGet$element_name() {
    return this.e$element_name;
  }
$end: alternated_list_element_accessor$
$macro: end_element_declaration $
  private final End e\$end;
$end: end_element_declaration $
$macro: end_element_accessor $
  End internalGet\$end() {
    return this.e\$end;
  }
$end: end_element_accessor$
}
$end: alternative $

$comment: ========== walker ========== $

$macro: walker $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

public class Walker {

  public void walk(Node node) {
    if(node != null) {
      node.apply(this);
    }
  }

  public void walkChildren(Node node) {
    if(node != null) {
      node.applyOnChildren(this);
    }
  }

$macro: walker_in(type_name) $
  public void in$type_name(N$type_name node) {
    defaultIn(node);
  }

$end: walker_in $
  public void defaultIn(Node node) {
  }

$macro: walker_case(type_name) $
  public void case$type_name(N$type_name node) {
    defaultCase(node);
  }

$end: walker_case $
  public void defaultCase(Node node) {
    node.applyOnChildren(this);
  }

$macro: walker_out(type_name) $
  public void out$type_name(N$type_name node) {
    defaultOut(node);
  }

$end: walker_out $
  public void defaultOut(Node node) {
  }
}
$end: walker $

$comment: ========== CSTProductionType ========== $

$macro: cst_production_type $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

enum CSTProductionType {
$macro: cst_production_type_declaration(name) $
  $name,
$end: cst_production_type_declaration $
}
$end: cst_production_type $

$comment: ========== parser ========== $

$macro: parser $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;
import java.util.*;

public class Parser {

  private final Lexer lexer;
  private final ParseStack stack = new ParseStack();

  public Parser(Reader reader) {
    this.lexer = new Lexer(reader);
  }

  public Node parse()
      throws ParserException, LexerException, IOException {

    Node tree = null;
    while(tree == null) {
      tree = stack.getState().apply(this);
    }

    return tree;
  }

  ParseStack getStack() {
    return this.stack;
  }

  private LinkedList<Token> lookList = new LinkedList<Token>();

  Token look(int distance)
      throws LexerException, IOException {
    while(lookList.size() < distance) {
      lookList.addLast(lexer.next());
    }
    return lookList.get(distance - 1);
  }

  void shift()
      throws ParserException, LexerException, IOException {
    Token token;
    if(lookList.size() > 0) {
      token = lookList.removeFirst();
    }
    else {
      token = lexer.next();
    }

    stack.push(new AbstractForest(CSTProductionType.NOT_A_PRODUCTION,token), stack.getState().getTokenTarget(token));
  }
}

$end: parser$

$comment: ========== parseStack ========== $

$macro: parse_stack $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class ParseStack {
  private ParseStackEntry stack = new ParseStackEntry(null, null, L_0.instance);
  private ParseStackEntry freeList;

  void push(AbstractForest forest, LRState state) {
    ParseStackEntry entry;
    if(freeList != null) {
      entry = freeList;
      freeList = freeList.previous;
      entry.set(stack,forest, state);
    }
    else {
      entry = new ParseStackEntry(stack, forest, state);
    }
    stack = entry;
  }

  LRState getState() {
    return stack.state;
  }

  AbstractForest pop() {
    AbstractForest forest = stack.forest;
    ParseStackEntry entry = stack;
    stack = stack.previous;
    entry.set(freeList, null, null);
    freeList = entry;
    return forest;
  }

  private static class ParseStackEntry {
    ParseStackEntry previous;
    AbstractForest forest;
    LRState state;

    ParseStackEntry(
        ParseStackEntry previous,
        AbstractForest forest,
        LRState state) {
     this.previous = previous;
     this.forest = forest;
     this.state = state;
    }

    void set(
        ParseStackEntry previous,
        AbstractForest forest,
        LRState state) {
     this.previous = previous;
     this.forest = forest;
     this.state = state;
   }
  }
}

$end: parse_stack$

$comment: ========== abstract_forest ========== $

$macro: abstract_forest $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.util.*;

class AbstractForest{

        private final CSTProductionType type;
        private final List<Node> nodes;

        AbstractForest(CSTProductionType type,List<Node> nodes){

          this.type = type;
          this.nodes = nodes;
        }

        AbstractForest(CSTProductionType type,Node node){

          this.type = type;
          this.nodes = new LinkedList<Node>();
          this.nodes.add(node);
        }

        CSTProductionType getProductionType(){
          return type;
        }

        List<Node> getNodes(){
          return nodes;
        }
}

$end: abstract_forest $


$comment: ========== lr_state ========== $

$macro: lr_state $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;

abstract class LRState {

  abstract Node apply(Parser parser)
      throws ParserException, LexerException, IOException;

  abstract LRState getTokenTarget(Token token)
      throws ParserException, LexerException, IOException;

  abstract LRState getProductionTarget(CSTProductionType cstType)
      throws ParserException, LexerException, IOException;
}
$end: lr_state $

$macro: lr_state_singleton(number) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io.*;
import java.util.*;

class L_$number
    extends LRState {

  static final L_$number instance = new L_$number();

  private L_$number() {
  }

  @Override
  Node apply(Parser parser)
      throws ParserException, LexerException, IOException {

$macro: distance(distance) $
    // LR($distance) decisions
$macro: action $
    $expand: normal_group, false_group, before_first="if (", separator=" && ", after_last=") " ${
$macro: normal_group$
$expand: normal_condition, end_condition, before_many="(", separator=" || ", after_many=")" $
$end: normal_group $
$macro: normal_condition(ahead,token_type) $
parser.look($ahead).getInternalType() == Token.InternalType.T_$(token_type)$no_eol$
$end: normal_condition $
$macro: end_condition(ahead) $
parser.look($ahead).getInternalType() == Token.InternalType.TEnd$no_eol$
$end: end_condition $
$macro: false_group $
false$no_eol$
$end: false_group $
$macro: shift $
      parser.shift();
      return null;
$end: shift $
$macro: reduce(reduced_production) $
      ParseStack stack = parser.getStack();
$expand: reduce_normal_pop, reduce_end_pop $
$macro: reduce_normal_pop(element_name) $
      AbstractForest l$(element_name) = stack.pop();
$end: reduce_normal_pop $
$macro: reduce_end_pop $
      End l\$end = (End) stack.pop().getNodes().get(0);
$end: reduce_end_pop $
$macro: reduce_decision $
      List<Node> trees = new LinkedList<Node>();
      $expand: new_tree_class,new_list $
$macro: new_tree_class(element_type,element_name) $
$expand: new_tree_class,new_list $
        N$(element_type) n$(element_name) = new N$(element_type) (-1, -1$expand: normal_parameter,null_parameter,separated_parameter,alternated_parameter,new_parameter, end_parameter, before_first=", ", separator=", " $);
$end: new_tree_class$
$macro: new_list(list_name) $
$expand: new_tree_class,new_list $
        $expand:normal_declaration,alternated_declaration,separated_declaration$ n$(list_name) = new $expand:normal_declaration,alternated_declaration,separated_declaration$ ($expand: string_parameter,normal_parameter,separated_parameter,alternated_parameter,new_parameter, separator=", "$);
$expand: add_pop_element,add_pop_element_left,add_pop_element_right,add_new_element,add_pop_list,add_pop_separated_list,add_pop_alternated_list,add_pop_reverse_separated_list,add_pop_reverse_alternated_list,add_new_list $
$macro: normal_declaration(normal_list_type) $
NodeList<N$(normal_list_type)>$no_eol$
$end: normal_declaration$
$macro: alternated_declaration(left_list_type,right_list_type) $
PairNodeList<N$(left_list_type),N$(right_list_type)>$no_eol$
$end: alternated_declaration$
$macro: separated_declaration(left_list_type,right_list_type) $
SeparatedNodeList<N$(left_list_type),N$(right_list_type)>$no_eol$
$end: separated_declaration$
$end: new_list$
$expand: add_l_to_forest,add_null_to_forest,add_n_to_forest $
$macro: add_pop_to_forest(element_name,index) $
      trees.add(l$(element_name).getNodes().get($index));
$end: add_pop_to_forest $
$macro: add_l_to_forest(element_name) $
      trees.add(l$(element_name));
$end: add_l_to_forest $
$macro: add_null_to_forest $
      trees.add(null);
$end: add_null_to_forest $
$macro: add_n_to_forest(element_name) $
      trees.add(n$(element_name));
$end: add_n_to_forest $
      stack.push(new AbstractForest(CSTProductionType.$reduced_production,trees), stack.getState().getProductionTarget(CSTProductionType.$reduced_production));
      return null;
$end: reduce_decision $
$macro: normal_parameter(element_type,element_name,index) $
(N$(element_type)) l$(element_name).getNodes().get($index)$no_eol$
$end: normal_parameter $
$macro: separated_parameter(left_element_type,right_element_type,element_name,index) $
(SeparatedNodeList<N$(left_element_type),N$(right_element_type)>) l$(element_name).getNodes().get($index)$no_eol$
$end: separated_parameter $
$macro: alternated_parameter(left_element_type,right_element_type,element_name,index) $
(PairNodeList<N$(left_element_type),N$(right_element_type)>) l$(element_name).getNodes().get($index)$no_eol$
$end: alternated_parameter $
$macro: new_parameter(element_name) $
n$(element_name)$no_eol$
$end: new_parameter $
$macro: null_parameter $
null$no_eol$
$end: null_parameter $
$macro: end_parameter $
l\$end$no_eol$
$end: end_parameter $
$macro: string_parameter(string)$
$(string)$no_eol$
$end: string_parameter$
$macro: add_pop_element(list_name,element_name,element_type,index) $
      n$(list_name).add((N$(element_type))l$(element_name).getNodes().get($index));
$end: add_pop_element $
$macro: add_pop_element_left(list_name,element_name,element_type,index) $
      n$(list_name).addLeft((N$(element_type))l$(element_name).getNodes().get($index));
$end: add_pop_element_left $
$macro: add_pop_element_right(list_name,element_name,element_type,index) $
      n$(list_name).addRight((N$(element_type))l$(element_name).getNodes().get($index));
$end: add_pop_element_right $
$macro: add_new_element(list_name,element_name) $
      n$(list_name).add($element_name);
$end: add_new_element $
$macro: add_pop_list(list_name,element_name,element_type,index) $
      n$(list_name).addAll((NodeList<N$(element_type)>)l$(element_name).getNodes().get($index));
$end: add_pop_list $
$macro: add_pop_separated_list(list_name,element_name,left_type,right_type,index) $
      n$(list_name).addAll(((SeparatedNodeList<N$(left_type),N$(right_type)>)l$(element_name).getNodes().get($index))$expand: get_left,get_right $);
$end: add_pop_separated_list $
$macro: add_pop_alternated_list(list_name,element_name,left_type,right_type,index) $
      n$(list_name).addAll(((PairNodeList<N$(left_type),N$(right_type)>)l$(element_name).getNodes().get($index))$expand: get_left,get_right $);
$end: add_pop_alternated_list $
$macro: add_pop_reverse_separated_list(list_name,element_name,left_type,right_type,index) $
      n$(list_name).addAllReverse(((SeparatedNodeList<N$(left_type),N$(right_type)>)l$(element_name).getNodes().get($index))$expand: get_left,get_right $);
$end: add_pop_reverse_separated_list $
$macro: add_pop_reverse_alternated_list(list_name,element_name,left_type,right_type,index) $
      n$(list_name).addAllReverse(((PairNodeList<N$(left_type),N$(right_type)>)l$(element_name).getNodes().get($index))$expand: get_left,get_right $);
$end: add_pop_reverse_alternated_list $
$macro: get_left$
.getLeft()$no_eol$
$end: get_left$
$macro: get_right$
.getRight()$no_eol$
$end: get_right$
$macro: add_new_list(list_name,element_name) $
      n$(list_name).addAll($element_name);
$end: add_new_list $
$macro: accept_decision(element_name) $
      return l$element_name.getNodes().get(0);
$end: accept_decision $
$end: reduce $
    }
$end: action $
$end: distance $
$macro: lr1_or_more $
    parser.shift();
    return null;
$end: lr1_or_more $
  }

  @Override
  LRState getTokenTarget(Token token)
      throws ParserException, LexerException, IOException {

    switch(token.getInternalType()) {
$macro: normal_token_lr_transition_target(node_type, target) $
    case T_$(node_type):
      return L_$target.instance;
$end: normal_token_lr_transition_target $
$macro: end_token_lr_transition_target(target) $
    case TEnd:
      return L_$target.instance;
$end: end_token_lr_transition_target $
    default:
      throw new ParserException(token);
    }
  }

  @Override
  LRState getProductionTarget(CSTProductionType type)
      throws ParserException, LexerException, IOException {

    switch(type) {
$macro: production_lr_transition_target(node_type, target) $
    case $(node_type):
      return L_$target.instance;
$end: production_lr_transition_target $
    default:
      throw new RuntimeException("internal error in parsing tables");
    }
  }
}
$end: lr_state_singleton $
