$comment$
This file is part of SableCC ( http://sablecc.org ).

See the NOTICE file distributed with this work for copyright information.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
$end$

$comment: ========== header ========== $

$text: header $
/* This file was generated by SableCC ( http://sablecc.org ). */
$end: header $

$comment: ========== default_package ========== $

$macro: default_package(language_name) $
package language_$language_name
$end: default_package $

$comment: ========== specified_package ========== $

$macro: specified_package(language_name, package) $
package $package.language_$language_name
$end: specified_package $

$comment: ========== node ========== $

$macro: node(pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class Node {

  import Node._

  import Type._

  def tpe: Type

  import ProductionType._

  def productionType: ProductionType

  def text: String
  def line: Int
  def pos: Int

  var parent: Node = _

  override def toString =
    "\\"" + text + "\\"@(" + line + "," + pos + ")";

  import InternalType._

  protected[$pkg] def internalType: InternalType
}

object Node {

  object Type extends Enumeration {
    type Type = Value
    val
$macro: node_type_enum_entry(name) $
    T_$name,
$end: node_type_enum_entry $
    TEnd,
    TAnonymous = Value
  }

  object ProductionType extends Enumeration {
    type ProductionType = Value
    val
$macro: node_production_type_enum_entry(name) $
    T_$name,
$end: node_production_type_enum_entry $
    TNotAProduction = Value
  }

  object InternalType extends Enumeration {
    type InternalType = Value
    val
$macro: node_internal_type_enum_entry(name) $
    T_$name,
$end: node_internal_type_enum_entry $
    TEnd = Value
  }
  
}
$end: node $

$comment: ========== token ========== $

$macro: token $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class Token(val text: String, val line: Int, val pos: Int)
    extends Node {

  import Node._

  override def productionType = ProductionType.TNotAProduction

}
$end: token $

$comment: ========== custom_token ========== $

$macro: custom_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

case class N$name(text: String, line: Int, pos: Int)
    extends Token(text, line, pos) {

  import Node._ 

  override def tpe = Type.T_$name

  override def internalType = InternalType.T_$name

}
$end: custom_token $

$comment: ========== anonymous_token ========== $

$macro: anonymous_token(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class N$name protected (text: String, line: Int, pos: Int)
    extends Token(text, line, pos) {

  import Node._

  override def tpe() = Type.TAnonymous

  override def internalType = InternalType.T_$name
}
$end: anonymous_token $

$comment: ========== lexer ========== $

$macro: lexer(pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io._
import Symbol._

class Lexer(reader: Reader) {

  private val br = new BufferedReader(reader)
  private val buffer = new StringBuilder
  private var eof = false
  private var line = 1
  private var pos = 1
  private var last_is_cr = false
  private var sb: StringBuilder = null
  private var acceptLine_ = 0
  private var acceptPos_ = 0
  private var current_sb_length = 0
  private var sb_contains_eof = false
$macro: marker_declaration(name) $
  private var marker$name = 0
$end: marker_declaration $

$macro: set_marker_declaration(name) $
  protected[$pkg] def setMarker$name {
    this.marker$name = this.current_sb_length
  }
$end: set_marker_declaration $

  def next: Token = {
    var token: Token = null
    do {
      token = internalNext
    } while (token == null)
    token
  }

  protected def internalNext: Token = {

    var first = true

    val sb = new StringBuilder
    var state: State = S_0

    while(state.stateType == State.StateType.TRANSITION) {
      val transitionState = state.asInstanceOf[TransitionState]

      this.current_sb_length = sb.length
      transitionState.marker(this)

      var symbol: Symbol = null
      if(buffer.length > 0) {
        val c = buffer.charAt(0)
        buffer.deleteCharAt(0)

        sb.append(c)
        symbol = Symbol.symbol(c)
      }
      else if(this.eof) {
        if(sb.length == 0) {
          return new End(this.line, this.pos)
        }
        this.sb_contains_eof = true
        symbol = Symbol.Symbol_end
      }
      else {
        val i = br.read
        if(i == -1) {
          this.eof = true
          br.close

          if(sb.length == 0) {
            return new End(this.line, this.pos)
          }
          this.sb_contains_eof = true
          symbol = Symbol.Symbol_end
        }
        else {
          val c = i.toChar

          sb.append(c)
          symbol = Symbol.symbol(c)
        }
      }

      if(symbol == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos)
      }

      state = transitionState.target(symbol)

      if(state == null) {
        throw new LexerException(sb.charAt(0), this.line, this.pos)
      }
    }

    val finalState = state.asInstanceOf[FinalState]

    this.sb = sb

    finalState.token(this)
  }

  protected[$pkg] def acceptLine = this.acceptLine_
  private def acceptLine_=(i: Int) = this.acceptLine_ = i

  protected[$pkg] def acceptPos = this.acceptPos_
  private def acceptPos_=(i: Int) = this.acceptPos_ = i

  private def updateLinePos(text: String) {
    if(this.last_is_cr) {
      if(text.length > 0) {
        if(text.charAt(0) != 10) {
          this.last_is_cr = false
          this.line += 1
          this.pos = 1
        }
      }
      else if(this.buffer.length > 0) {
        if(this.buffer.charAt(0) != 10) {
          this.last_is_cr = false
          this.line += 1
          this.pos = 1
        }
      }
    }

    this.acceptLine = line
    this.acceptPos = pos

    for(i <- 0 until text.length) {
      val c = text.charAt(i)

      if(c == 10) {
        this.line += 1
        this.pos = 1
      }
      else {
        if(last_is_cr) {
          this.line += 1
          this.pos = 2
        }
        else {
          this.pos += 1
        }
      }

      this.last_is_cr = c == 13
    }
  }

  protected[$pkg] def accept(backCount: Int) = {
    var bc = backCount
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false
      bc -= 1
    }
    val text = this.sb.toString.substring(0, this.sb.length - bc)
    val leftover = this.sb.toString.substring(this.sb.length - bc, this.sb.length)
    this.buffer.insert(0, leftover)
    updateLinePos(text)
    text
  }

$macro: accept_marker_declaration(name) $
  protected[$pkg] def acceptWithMarker$name(backCount: Int) = {
    var bc = backCount
    if(this.sb_contains_eof) {
      this.sb_contains_eof = false
      bc -= 1
    }
    val text = this.sb.toString.substring(0, this.marker$name - bc)
    val leftover = this.sb.toString.substring(this.marker$name - bc, this.sb.length)
    this.buffer.insert(0, leftover)
    updateLinePos(text)
    text
  }
$end: accept_marker_declaration $

}
$end: lexer $

$comment: ========== state ========== $

$macro: state(pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class State {

  import State.StateType._

  protected[$pkg] def stateType: StateType
}
object State {
  object StateType extends Enumeration {
    type StateType = Value
    val TRANSITION, FINAL = Value
  }
}
$end: state $

$comment: ========== transition_state ========== $

$macro: transition_state(pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class TransitionState
    extends State {

  import State._
  import Symbol._

  protected[$pkg] def marker(lexer: Lexer): Unit
  protected[$pkg] def target(symbol: Symbol): State

  protected[$pkg] def stateType = StateType.TRANSITION
}
$end: transition_state $

$comment: ========== final_state ========== $

$macro: final_state(pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

abstract class FinalState
    extends State {

  import State._

  protected[$pkg] def token(lexer: Lexer): Token

  protected[$pkg] def stateType = StateType.FINAL
}
$end: final_state $

$comment: ========== transition_state_singleton ========== $

$macro: transition_state_singleton(number,pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

object S_$number
    extends TransitionState {

  import Symbol._

$macro: set_marker(name) $
  protected[$pkg] def marker(lexer: Lexer) {
    lexer.setMarker$name
  }
$end: set_marker $
$macro: no_marker $
  protected[$pkg] def marker(lexer: Lexer) {
  }
$end: no_marker $

  protected[$pkg] def target(symbol: Symbol) = symbol match {
$macro: transition_target(symbol, target) $
    case Symbol.Symbol_$(symbol) => S_$target
$end: transition_target $
    case _ => null
  }

}
$end: transition_state_singleton $

$comment: ========== final_state_singleton ========== $

$macro: final_state_singleton(number,back_count,pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

object S_$number
    extends FinalState {

  protected[$pkg] def token(lexer: Lexer) = {
$macro: accept_token_no_marker $
    val text = lexer.accept($back_count)
$end: accept_token_no_marker $
$macro: accept_token_with_marker(marker_name) $
    val text = lexer.acceptWithMarker$marker_name($back_count)
$end: accept_token_with_marker $
    val line = lexer.acceptLine
    val pos = lexer.acceptPos

$macro: accept_normal_token(token_name) $
    new N$token_name(text, line, pos)
$end: accept_normal_token $
$macro: accept_ignored_token $
    null
$end: accept_ignored_token $
  }
}
$end: final_state_singleton $

$comment: ========== symbol ========== $

$macro: symbol $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

object Symbol extends Enumeration {
  type Symbol = Value
  val
$macro: symbol_declaration(name) $
  Symbol_$name,
$end: symbol_declaration $
  Symbol_end = Value

  def symbol(c: Char): Symbol = c match {
$macro: single_char(bound, name) $
    case $(bound) => Symbol_$name
$end: single_char $
$macro: open_interval(name) $
      case _ => Symbol_$name
$end: open_interval $
$macro: open_left_interval(upper_bound, name) $
      case _ if(c <= $upper_bound) => Symbol_$name
$end: open_left_interval $
$macro: open_right_interval(lower_bound, name) $
      case _ if(c >= $lower_bound) => Symbol_$name
$end: open_right_interval $
$macro: interval(lower_bound, upper_bound, name) $
      case _ if(c >= $lower_bound && c <= $upper_bound) => Symbol_$name
$end: interval $
      case _ => null
  }
}
$end: symbol $

$comment: ========== lexer_exception ========== $

$macro: lexer_exception $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class LexerException(val char: Char, val line: Int, val pos: Int)
    extends Exception() {

  override def getMessage = "unrecognized char '" + char + "' on line " + line + ", pos " + pos
}
$end: lexer_exception $

$comment: ========== parser_exception ========== $

$macro: parser_exception $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class ParserException(val token: Token)
    extends Exception() {

  override def getMessage = "unexpected token '" + token.text + "' on line " + token.line + ", pos " + token.pos
}
$end: parser_exception $

$comment: ========== test ========== $

$macro: test $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io._
object Test {

  def main(args: Array[String]) {

    val in = 
      if(args.length > 0)
	new FileReader(args(0))
      else
        new InputStreamReader(System.in)

    val syntaxTree = new Parser(in).parse
    println()
    new Traverser() {
      override def traverse(node: Node) = node match {
        case _: Token =>
          println(node.tpe + ":\\"" + node.text + "\\"@(" + node.line + "," + node.pos + ")");
        case _ => super.traverse(node)
      }
    }.traverse(syntaxTree)
  }
}
$end: test $

$comment: ========== end ========== $

$macro: end(pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class End(line: Int, pos: Int)
    extends Token("", line, pos) {

  import Node._

  override def tpe = Type.TEnd

  protected[$pkg] override def internalType = InternalType.TEnd
}
$end: end $

$comment: ========== production ========== $

$macro: production(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

$macro: named_production_header $
abstract class N$name
$end: named_production_header $
$macro: anonymous_production_header(pkg) $
protected[$pkg] protected abstract class N$name
$end: anonymous_production_header $
    extends Node
$end: production $

$comment: ========== package_protected ========== $

$macro: package_protected(pkg) $
protected[$pkg] $no_eol$
$end: package_protected $

$comment: ========== alternative ========== $

$macro: alternative(name) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

$expand: package_protected $
case class N$(name)$expand: protected_constructor $ (val line: Int, val pos: Int$expand: normal_constructor_parameter, end_constructor_parameter, before_first=", ", separator=", " $)
    extends $expand: alternative_named_parent, alternative_node_parent $ {
$macro: protected_constructor(pkg) $
 protected[$pkg]$no_eol$
$end: protected_constructor $
$macro: alternative_named_parent(parent) $
N$(parent)$no_eol$
$end: alternative_named_parent $
$macro: alternative_node_parent $
Node$no_eol$
$end: alternative_node_parent $
$macro: normal_constructor_parameter(element_type, element_name) $
private val e$(element_name): N$(element_type)$no_eol$
$end: normal_constructor_parameter $
$macro: end_constructor_parameter $
private val e\$end: End$no_eol$
$end: end_constructor_parameter $

  import Node._

  override def text = null

  override def tpe =
$macro: named_alt_type $
    Type.T_$name
$end: named_alt_type $
$macro: anonymous_alt_type $
    Type.TAnonymous
$end: anonymous_alt_type $

  override def productionType = 
$macro: alt_prod_type(prod_name) $
    ProductionType.T_$prod_name
$end: alt_prod_type $

  override def internalType =
    InternalType.T_$name

$expand: public_element_accessor, before_first="\n", separator="\n" $
$expand: normal_element_accessor, end_element_accessor, before_first="\n", separator="\n" $
$macro: public_element_accessor(element_name) $
  def $(element_name): $expand: public_element_type, token_element_type $ = 
$macro: public_element_type(element_type) $
N$(element_type)$no_eol$
$end: public_element_type $
$macro: token_element_type $
Token$no_eol$
$end: token_element_type $
    this.e$element_name
$end: public_element_accessor$
$macro: normal_element_accessor(element_type, element_name,pkg) $
  protected[$pkg] def internalGet$(element_name): N$element_type = this.e$element_name
$end: normal_element_accessor$

$macro: end_element_accessor(pkg) $
  protected[$pkg] def internalGet\$end: End = this.e\$end
$end: end_element_accessor$

}
object N$(name) {
  def unapply(node: N$(name)): Option[(Int, Int$expand: extractor_type, before_first=", ", separator=", " $)] =
    Some((node.line, node.pos$expand: extractor_parameter, before_first=", ", separator=", " $))
}

$comment: return type for the unapply method $
$macro: extractor_type(element_type) $
$(element_type)$no_eol$
$end: extractor_type $

$comment: parameter of the unapply method $
$macro: extractor_parameter(element_name) $
node.internalGet$(element_name)$no_eol$
$end: extractor_parameter $
$end: alternative $

$comment: ========== traverser ========== $

$macro: traverser $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class Traverser {
  def traverse(node: Node): Unit = node match {
$expand: normal_traverser_case $
$macro: normal_traverser_case(case_type) $
    case $case_type(line, pos$expand: case_constructor_parameter, end_case_constructor_parameter, before_first=", ", separator=", " $) =>
$expand: child_traverse $
$macro: case_constructor_parameter(case_name) $
e$(case_name)$no_eol$
$end: case_constructor_parameter $
$macro: end_case_constructor_parameter $
e\$end$no_eol$
$end: end_case_constructor_parameter $
$macro: child_traverse(element_name) $
      traverse(e$element_name)
$end: child_traverse $
$end: normal_traverser_case $
    case _ => // do nothing
  }
}
$end: traverser $

$comment: ========== transformer ========== $

$macro: transformer $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

class Transformer {
  def transform(node: Node): Node = node match {
$expand: normal_transformer_case $
$macro: normal_transformer_case(case_type) $
    case $case_type(line, pos$expand: transform_case_constructor_parameter, before_first=", ", separator=", " $) =>
      $case_type.copy(line, pos$expand: child_transform, before_first=", ", separator=", " $)
$macro: transform_case_constructor_parameter(case_name) $
$(case_name)$no_eol$
$end: transform_case_constructor_parameter $
$macro: child_transform(element_name, element_type) $
e$element_name = transform(e$element_name).asInstanceOf[$element_type]$no_eol$
$end: child_transform $
$end: normal_transformer_case $
    case _ => node
  }
}
$end: transformer $

$comment: ========== parser ========== $

$macro: parser(pkg) $
$insert: header $
$expand: default_package, specified_package, before_first="\n" $

import java.io._
import java.util._

class Parser(reader: Reader) {

  private val lexer = new Lexer(reader)
  protected[$pkg] val stack = new ParseStack

  def parse: Node = {

    var tree: Node = null
    while(tree == null) {
      tree = stack.state(this)
    }

    tree
  }

  private val lookList = new LinkedList[Token]

  protected[$pkg] def look(distance: Int) = {
    while(lookList.size < distance) {
      lookList.addLast(lexer.next)
    }
    lookList.get(distance - 1)
  }

  protected[$pkg] def shift {
    val token =
      if(lookList.size > 0)
	lookList.removeFirst
      else
	lexer.next
    stack.push(token, stack.state.target(token))
  }
}

protected[$pkg] class ParseStack {

  import ParseStack._

  private var stack = new ParseStackEntry(null, null, L_0)
  private var freeList: ParseStackEntry = _

  protected[$pkg] def push(node: Node, state: LRState) {
    var entry: ParseStackEntry = null
    if(freeList != null) {
      entry = freeList
      freeList = freeList.previous
      entry.set(stack, node, state)
    }
    else {
      entry = new ParseStackEntry(stack, node, state)
    }
    stack = entry
  }

  protected[$pkg] def state: LRState = stack.state

  protected[$pkg] def pop = {
    val node = stack.node
    val entry = stack
    stack = stack.previous
    entry.set(freeList, null, null)
    freeList = entry
    node
  }
}

protected[$pkg] object ParseStack {

  class ParseStackEntry(var previous: ParseStackEntry, var node: Node, var state: LRState) {

    def set(
        previous: ParseStackEntry,
        node: Node,
        state: LRState) {
     this.previous = previous;
     this.node = node;
     this.state = state;
   }
  }
}

protected[$pkg] abstract class LRState {

  protected[$pkg] def apply(parser: Parser): Node
  protected[$pkg] def target(node: Node): LRState
}
$macro: lr_state_singleton(number) $

protected[$pkg] object L_$number
    extends LRState {

  override def apply(parser: Parser): Node = {

$macro: distance(distance) $
    // LR($distance) decisions
$macro: action $
    $expand: normal_group, false_group, before_first="if (", separator=" && ", after_last=") " ${
$macro: normal_group$
$expand: normal_condition, end_condition, before_many="(", separator=" || ", after_many=")" $
$end: normal_group $
$macro: normal_condition(ahead,token_type) $
parser.look($ahead).internalType == Node.InternalType.T_$(token_type)$no_eol$
$end: normal_condition $
$macro: end_condition(ahead) $
parser.look($ahead).internalType == Node.InternalType.TEnd$no_eol$
$end: end_condition $
$macro: false_group $
false$no_eol$
$end: false_group $
$macro: shift $
      parser.shift
      return null
$end: shift $
$macro: reduce(alternative) $
      val stack = parser.stack

$expand: reduce_normal_pop, reduce_end_pop $
$macro: reduce_normal_pop(element_type, element_name) $
      val l$element_name = stack.pop.asInstanceOf[N$element_type]
$end: reduce_normal_pop $
$macro: reduce_end_pop $
      val l\$end = stack.pop.asInstanceOf[End]
$end: reduce_end_pop $

$macro: normal_parameter(element_name) $
l$(element_name)$no_eol$
$end: normal_parameter $
$macro: end_parameter $
l\$end$no_eol$
$end: end_parameter $
$macro: reduce_decision $
      val l$alternative = new N$alternative(-1, -1$expand: normal_parameter, end_parameter, before_first=", ", separator=", " $)
      stack.push(l$alternative, stack.state.target(l$alternative))
      return null
$end: reduce_decision $
$macro: accept_decision(element_name) $
      return l$element_name
$end: accept_decision $
$end: reduce $
    }
$end: action $
$end: distance $
$macro: lr1_or_more $
    parser.shift
    return null
$end: lr1_or_more $
  }

  import Node._
  
  protected[$pkg] override def target(node: Node): LRState = node.productionType match {
$macro: production_lr_transition_target(node_type, target) $
    case ProductionType.T_$(node_type) => L_$target
$end: production_lr_transition_target $
    case _ => node.internalType match {
$macro: normal_token_lr_transition_target(node_type, target) $
        case InternalType.T_$(node_type) => L_$target
$end: normal_token_lr_transition_target $
$macro: end_token_lr_transition_target(target) $
        case InternalType.TEnd => L_$target
$end: end_token_lr_transition_target $
        case _ =>
          throw new ParserException(node.asInstanceOf[Token])
      }
    }
}
$end: lr_state_singleton $
$end: parser $
